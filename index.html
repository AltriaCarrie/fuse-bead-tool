<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>拼豆图片生成器</title>
    <link rel="stylesheet" href="bootstrap-4.3.1/css/bootstrap.min.css">
    <link href="css/style.css" rel="stylesheet">
    <script src="js/palette.js"></script>
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script src="js/popper.min.js"></script>
    <script src='bootstrap-4.3.1/js/bootstrap.min.js'></script>
</head>

<body>
    <div class="card">
        <div class="card-body">
            <div class="custom-file">
                <input type="file" class="custom-file-input" id="imageChooser"
                    accept="image/png, image/jpeg, image/gif" />
                <label class="custom-file-label" for="imageChooser">选择图片</label>
            </div>
        </div>
    </div>
    <div id='mainContent'>
        <div class="row">
            <div class="col">
                <div class="card">
                    <div class="card-header">
                        原始图片
                    </div>
                    <div class="card-body">
                        <canvas id="originalCanvas"></canvas>
                    </div>
                </div>
            </div>
            <div class="col">
                <div class="card">
                    <div class="card-header">
                        完整图片
                    </div>
                    <div class="card-body">
                        <canvas id="fullCanvas"></canvas>
                    </div>
                </div>
            </div>
            <div class="col">
                <div class="card">
                    <div class="card-header">
                        图片切块
                    </div>
                    <div class="card-body">
                        <table id='sliceImageContainer' class='table-bordered'>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        <div class="card">
            <div class="card-header row">
                <label id='largePicInfo' class="col-form-label col-sm-8"></label>
                <div class="dropdown col-sm-2">
                    <button class="btn btn-outline-primary dropdown-toggle" type="button" id="dropdownColorSum"
                        data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        颜色统计
                    </button>
                    <div class="dropdown-menu overflow-auto" aria-labelledby="dropdownColorSum" id="colorSum"
                        style="max-height:800px;">
                        <table class="table table-sm">
                            <thead>
                                <th style="width: 36px;"> </th>
                                <th>颜色</th>
                                <th>数量</th>
                            </thead>
                            <tbody id="colorSumTable">
                            </tbody>
                        </table>
                    </div>
                </div>
                <div class="dropdown col-sm-2">
                    <button class="btn btn-outline-danger dropdown-toggle" type="button" id="dropdownColorReplace"
                        data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        颜色替换
                    </button>
                    <div class="dropdown-menu dropdown-menu-right overflow-auto" aria-labelledby="dropdownColorReplace"
                        style="max-height:800px;">
                        <div class="px-4 py-3">
                            <h6 class="dropdown-header">全体颜色替换列表</h6>
                            <table class="table table-sm" style="max-width: 150px;">
                                <thead>
                                    <th style="width: 36px;">旧</th>
                                    <th style="width: 36px;">新</th>
                                    <th style="width: 60px;"></th>
                                </thead>
                                <tbody id="colorReplaceTable">
                                </tbody>
                            </table>
                            <h6 class="dropdown-header">单个像素颜色替换列表</h6>
                            <table class="table table-sm">
                                <thead>
                                    <th>坐标</th>
                                    <th style="width: 36px;">旧</th>
                                    <th style="width: 36px;">新</th>
                                    <th style="width: 60px;"></th>
                                </thead>
                                <tbody id="pixelColorReplaceTable">
                                </tbody>
                            </table>
                            <div class="dropdown-divider"></div>
                            <button type="button" class="btn btn-danger btn-sm" id="removeAllColorReplace">全部删除</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="card-body" style='padding: 0.25rem;'>
                <canvas id="viewCanvas" style='width: 100%;'></canvas>
            </div>
        </div>
    </div>
    <div class="modal fade" id="colorModal" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h6 class="modal-title" id="pointDialogTitle"></h6>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div>
                        <button type="button" class="btn btn-primary" id='showSingleColor' value=''>只显示此颜色</button>
                        <hr />
                        <div>将颜色替换成：</div>
                        <div id="colorSelector">
                        </div>
                        <button type="button" class="btn btn-primary" id='replacePixel' value=''>只替换此像素点</button>
                        <button type="button" class="btn btn-primary" id='replaceColor' value=''>替换所有颜色</button>
                        <button type="button" class="btn btn-secondary" data-dismiss="modal">取消</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>

<script type="text/javascript">
    var pixelSize = 20,//马赛克像素尺寸（放大倍数）
        pieceSize = 48,//单块拼板容纳的拼豆数
        paletteMap = generatePaletteMap(samplePalette),//调色板对象集合
        similarColorCache = new Map(),//与实际颜色最相近的调色板颜色缓存
        paletteImageData = new Array(),//存储原始图片替换调色板颜色后的原图
        sliceImages = new Array(),//存储所有切块图的二维数组
        currentSliceImage = null;//当前显示的切块图位置（显示全图时为null）

    var selectedPixel = null,//当前选中的像素点（x,y,color)
        filterColor = '',//颜色筛选（只显示此颜色的色块）
        colorReplaceList = new Map(),//颜色替换列表
        pixelColorReplaceList = new Map();//颜色替换列表（单个像素）

    var isDragging = false,//视图是否正在拖拽中
        startDragX = 0,//拖拽起点X
        startDragY = 0;//拖拽起点Y

    var largeCanvas,//生成的马赛克大图Canvas，切出一部分显示在ViewCanvas
        largeCanvasStartOffsetX = 0,//拖拽开始时的背景X坐标偏移
        largeCanvasStartOffsetY = 0,//拖拽开始时的背景Y坐标偏移
        largeCanvasOffsetX = 0,//背景大图的X坐标偏移
        largeCanvasOffsetY = 0,//背景大图的Y坐标偏移
        isDrawingViewCanvas = false;//视图是否正在绘制中

    var rulerX1Canvas, rulerX2Canvas, rulerY1Canvas, rulerY2Canvas;//四个标尺的canvas

    $().ready(function () {
        var originalCanvas = document.getElementById('originalCanvas'),//原始图片canvas
            fullCanvas = document.getElementById('fullCanvas'),//完整图片canvas
            viewCanvas = document.getElementById('viewCanvas');//视图（可拖拽点击）canvas
        originalCanvas.width = 0, originalCanvas.height = 0;
        fullCanvas.width = 0, fullCanvas.height = 0;
        viewCanvas.width = viewCanvas.clientWidth, viewCanvas.height = viewCanvas.clientWidth;

        //显示调色板选色块
        let colorSelector = document.getElementById('colorSelector');
        let colorSelectorHtml = "";
        for (let color of paletteMap.values()) {
            let fontColor = getFontColor(color.r, color.g, color.b);
            let hex = rgbToHex(color.r, color.g, color.b);
            colorSelectorHtml += "<div style='background:#" + hex + ";color:" + fontColor + ";' color='" + hex + "'>" + color.name + "</div>";
        }
        colorSelector.innerHTML = colorSelectorHtml;

        //事件绑定
        {
            //窗口重绘后重设canvas尺寸
            window.addEventListener('resize', function (e) {
                viewCanvas.width = viewCanvas.clientWidth, viewCanvas.height = viewCanvas.clientWidth;
                if (!$('#mainContent').is(":hidden")) refreshImage();
            }, false);

            //图片加载事件
            let imageChooser = document.getElementById('imageChooser');
            imageChooser.onchange = function (e) {
                $(this).next('.custom-file-label').html(e.target.files[0].name);//bootstrap的file控件不会自动赋值，需要手工显示
                $('#mainContent').show();
                if (e.target.files.length <= 0) return;
                let imageFile = e.target.files[0];
                var reader = new FileReader();
                reader.onload = function (e) {
                    let originalCtx = originalCanvas.getContext('2d');
                    originalCtx.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
                    var image = new Image();
                    image.src = e.target.result;
                    image.onload = function (e) {
                        //重加载图片后的完整操作步骤：
                        //清空缓存和切块图片信息
                        similarColorCache = new Map();
                        sliceImages = new Array();

                        //绘制原图
                        originalCanvas.width = this.width;
                        originalCanvas.height = this.height;
                        originalCtx.drawImage(this, 0, 0);
                        //切掉原图白色和透明边
                        trimCanvas(originalCanvas);
                        //将原图颜色换成最相近的调色板颜色
                        toPaletteColor(originalCanvas, fullCanvas);
                        //将完整图片切成图块
                        sliceCanvasToImage(fullCanvas, 'sliceImageContainer');
                        //显示完整图片对应的马赛克大图
                        showFullImageView();
                    }
                    // 清空图片上传框的值
                    imageChooser.value = '';
                };

                reader.readAsDataURL(imageFile);
            };

            //点击显示全图
            fullCanvas.onclick = function (e) {
                showFullImageView();
            };

            //只显示某颜色按钮点击
            let showSingleColorButton = document.getElementById('showSingleColor');
            showSingleColorButton.onclick = function (e) {
                filterColor = selectedPixel.color;
                refreshImage();
                $('#colorModal').modal('hide');
            }

            //选色器点击
            $("#colorSelector>div").click(function (e) {
                $("#colorSelector>div.selected").removeClass("selected");
                $(this).addClass("selected");
                $('#replacePixel').val($(this).attr("color"));
                $('#replaceColor').val($(this).attr("color"));
            });

            //替换单个像素按钮点击
            let replacePixelButton = document.getElementById('replacePixel');
            replacePixelButton.onclick = function (e) {
                if (!this.value) return;
                //替换像素坐标使用的是全图真实坐标
                let position = getRealPosition(selectedPixel.x, selectedPixel.y);
                pixelColorReplaceList.set(position.x + ',' + position.y, { old: selectedPixel.color, new: this.value });
                refreshColorReplaceList();
                refreshImage();
                $('#colorModal').modal('hide');
            };

            //替换相同颜色按钮点击
            let replaceColorButton = document.getElementById('replaceColor');
            replaceColorButton.onclick = function (e) {
                if (!this.value) return;
                colorReplaceList.set(selectedPixel.color, this.value);
                refreshColorReplaceList();
                refreshImage();
                $('#colorModal').modal('hide');
            };

            //关闭颜色对话框
            $('#colorModal').on('hidden.bs.modal', function (e) {
                //清除当前对话框中的所选值
                selectedColor = null;
                $("#colorSelector>div.selected").removeClass("selected");
                $('#replacePixel').val("");
                $('#replaceColor').val("");
            });

            //移除所有颜色替换选项
            let removeAllColorReplaceButton = document.getElementById('removeAllColorReplace');
            removeAllColorReplaceButton.onclick = function (e) {
                colorReplaceList = new Map();
                pixelColorReplaceList = new Map();
                refreshColorReplaceList();
                refreshImage();
            };
        }

        //视图互动事件
        {
            viewCanvas.onmousedown = function (e) {
                if (e.buttons == 1 && largeCanvas) {//点击左键并且在大图已加载情况下开始拖拽
                    startDragX = e.clientX;
                    startDragY = e.clientY;
                    isDragging = true;
                }
            };
            viewCanvas.onmousemove = function (e) {
                if (isDragging && !isDrawingViewCanvas) {
                    //计算大图偏移值
                    largeCanvasOffsetX = largeCanvasStartOffsetX + startDragX - e.clientX;
                    largeCanvasOffsetY = largeCanvasStartOffsetY + startDragY - e.clientY;
                    if (largeCanvasOffsetX > largeCanvas.width - viewCanvas.width) largeCanvasOffsetX = largeCanvas.width - viewCanvas.width;
                    if (largeCanvasOffsetX < 0) largeCanvasOffsetX = 0;
                    if (largeCanvasOffsetY > largeCanvas.height - viewCanvas.height) largeCanvasOffsetY = largeCanvas.height - viewCanvas.height;
                    if (largeCanvasOffsetY < 0) largeCanvasOffsetY = 0;
                    requestAnimationFrame(function () {
                        showPartView();
                    });
                }
            };
            viewCanvas.onmouseup = function (e) {
                if (isDragging) {
                    if (e.clientX == startDragX && e.clientY == startDragY) {//如果未移动则触发点击事件
                        viewCanvasClick(e);
                    }
                }
                isDragging = false;
                largeCanvasStartOffsetX = largeCanvasOffsetX;
                largeCanvasStartOffsetY = largeCanvasOffsetY;
            };
            viewCanvas.onmouseout = function (e) {
                isDragging = false;
                largeCanvasStartOffsetX = largeCanvasOffsetX;
                largeCanvasStartOffsetY = largeCanvasOffsetY;
            };

            //触摸事件触发鼠标事件（移动端）
            viewCanvas.ontouchstart = function (e) {
                e.preventDefault();
                let touch = e.touches[0];
                viewCanvas.dispatchEvent(new MouseEvent("mousedown", {
                    buttons: 1,
                    clientX: touch.clientX,
                    clientY: touch.clientY
                }));
            };
            viewCanvas.ontouchmove = function (e) {
                e.preventDefault();
                let touch = e.touches[0];
                viewCanvas.dispatchEvent(new MouseEvent("mousemove", {
                    buttons: 1,
                    clientX: touch.clientX,
                    clientY: touch.clientY
                }));
            };
            viewCanvas.ontouchend = function (e) {
                e.preventDefault();
                let touch = e.changedTouches[0];
                viewCanvas.dispatchEvent(new MouseEvent("mouseup", {
                    buttons: 1,
                    clientX: touch.clientX,
                    clientY: touch.clientY
                }));
            };
            viewCanvas.ontouchcancel = function (e) {
                e.preventDefault();
                viewCanvas.dispatchEvent(new MouseEvent("mouseout", {}));
            };
        }

    });

    //视图点击或触摸事件
    function viewCanvasClick(e) {
        //实际在全图上的点击坐标
        let rect = viewCanvas.getBoundingClientRect();
        let realClickX = e.clientX - rect.left + largeCanvasOffsetX - (pixelSize + 1),
            realClickY = e.clientY - rect.top + largeCanvasOffsetY - (pixelSize + 1);
        //如果点在标尺上则不触发事件
        if (realClickX < 0 || realClickX > viewCanvas.width + largeCanvasOffsetX - 2 * (pixelSize + 1)
            || realClickY < 0 || realClickY > viewCanvas.height + largeCanvasOffsetY - 2 * (pixelSize + 1)) return;

        //如果当前正在过滤颜色，则恢复全部颜色
        if (filterColor) {
            filterColor = null;
            refreshImage();
            return;
        }

        //实际像素坐标
        let pointX = ~~(realClickX / (pixelSize + 1)),
            pointY = ~~(realClickY / (pixelSize + 1));
        let pointColor = getViewCanvasColor(pointX, pointY);
        if (!pointColor) return;
        let pointColorHex = rgbToHex(pointColor.r, pointColor.g, pointColor.b);
        let fontColor = getFontColor(pointColorHex);//浅色黑字，深色白字
        let color = paletteMap.get(pointColorHex);

        document.getElementById("pointDialogTitle").innerHTML =
            "<strong>坐标</strong>(" + (pointX + 1) + "," + (pointY + 1) + ")"
            + " <strong>色号</strong>" + color.name
            + " <div style='border:1px solid #060606; display:inline; color:" + fontColor + "; background:#" + pointColorHex + "'>#" + pointColorHex + "</div>";

        selectedPixel = { x: pointX, y: pointY, color: pointColorHex };

        $('#colorModal').modal('show');
    }

    //获取大图指定坐标点对应的图片色值
    function getViewCanvasColor(x, y) {
        //根据当前显示的是全图还是切块，读取坐标所在rgb数据
        let imageData, cursor;
        if (!currentSliceImage) {
            let fullCtx = fullCanvas.getContext('2d');
            imageData = fullCtx.getImageData(0, 0, fullCanvas.width, fullCanvas.height);
            cursor = (y * fullCanvas.width + x) * 4;
        } else {
            imageData = sliceImages[currentSliceImage.y][currentSliceImage.x];
            cursor = (y * pieceSize + x) * 4;
        }

        if (imageData.data[cursor + 3] == 0) return null;

        return {
            r: imageData.data[cursor],
            g: imageData.data[cursor + 1],
            b: imageData.data[cursor + 2],
        }
    }

    //去除canvas边缘的透明和白色像素
    function trimCanvas(canvas) {
        let ctx = canvas.getContext('2d'),
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height),
            bound = {
                top: null,
                left: null,
                right: null,
                bottom: null
            };

        for (let i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i + 3] !== 0
                && (imageData.data[i] < 250 && imageData.data[i + 1] < 250 && imageData.data[i + 2] < 250)) {//透明或者近似白色都作为白色去掉
                let x = (i / 4) % canvas.width;
                let y = ~~((i / 4) / canvas.width);

                if (bound.top === null) {
                    bound.top = y;
                }

                if (bound.left === null) {
                    bound.left = x;
                } else if (x < bound.left) {
                    bound.left = x;
                }

                if (bound.right === null) {
                    bound.right = x;
                } else if (bound.right < x) {
                    bound.right = x;
                }

                if (bound.bottom === null) {
                    bound.bottom = y;
                } else if (bound.bottom < y) {
                    bound.bottom = y;
                }
            }
        }

        //取出裁剪图片的宽高
        let trimHeight = bound.bottom - bound.top,
            trimWidth = bound.right - bound.left,
            trimmedImage = ctx.getImageData(bound.left, bound.top, trimWidth, trimHeight);

        canvas.width = trimWidth;
        canvas.height = trimHeight;
        ctx.putImageData(trimmedImage, 0, 0);
    }

    //将canvas颜色输出为最相近的调色板颜色
    function toPaletteColor(sourceCanvas, destCanvas) {
        let sourceCtx = sourceCanvas.getContext('2d'),
            destCtx = destCanvas.getContext('2d'),
            imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);

        //逐像素读取原图并寻找颜色值
        for (let i = 0; i < imageData.data.length; i += 4) {
            //读取颜色，如果透明则跳过
            let a = imageData.data[i + 3];
            if (a == 0) continue;

            //加透明度选项
            let r = ~~(imageData.data[i] * a / 255);
            let g = ~~(imageData.data[i + 1] * a / 255);
            let b = ~~(imageData.data[i + 2] * a / 255);

            let x = (i / 4) % sourceCanvas.width;
            let y = ~~((i / 4) / sourceCanvas.width);

            //绘制调色板图
            let similarColor = findSimilarColor(r, g, b);
            imageData.data[i] = similarColor.r;
            imageData.data[i + 1] = similarColor.g;
            imageData.data[i + 2] = similarColor.b;
            imageData.data[i + 3] = 255;//处理后一律变成不透明色
        }

        //保存换色后的原图
        paletteImageData = imageData;

        similarColorCache = null;
        destCanvas.width = sourceCanvas.width;
        destCanvas.height = sourceCanvas.height;
        destCtx.putImageData(imageData, 0, 0);
    }

    //将canvas分割为小图并输出为可点击的image集合
    function sliceCanvasToImage(canvas, sliceContainerName) {
        let ctx = canvas.getContext('2d'),
            rowCount = Math.ceil(canvas.height / pieceSize),//分割行数
            colCount = Math.ceil(canvas.width / pieceSize);//分割列数

        //生成table和image标签
        let tableHtml = "";
        for (let y = 0; y < rowCount; y++) {
            tableHtml += "<tr>";
            for (let x = 0; x < colCount; x++) {
                tableHtml += "<td><img id='sliceImage-" + y + "_" + x + "' /></td>";
            }
            tableHtml += "</tr>";
        }
        document.getElementById(sliceContainerName).innerHTML = tableHtml;

        //生成临时Canvas用于转换分割小图
        let tempCanvas = document.createElement('canvas'),
            tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = pieceSize;
        tempCanvas.height = pieceSize;
        tempCtx.font = ~~(pieceSize / 4) + 'px monospace';
        tempCtx.strokeStyle = '#000';
        tempCtx.textBaseline = 'bottom';
        tempCtx.textAlign = 'right';

        sliceImages = new Array(rowCount);
        for (let y = 0; y < rowCount; y++) {
            sliceImages[y] = new Array(colCount);
            for (let x = 0; x < colCount; x++) {
                tempCtx.clearRect(0, 0, pieceSize, pieceSize);
                //如果宽高超出canvas则减小
                let width = (x + 1 * pieceSize) > canvas.width ? canvas.width - x * pieceSize : pieceSize;
                let height = (y + 1 * pieceSize) > canvas.height ? canvas.height - y * pieceSize : pieceSize;
                let imageData = ctx.getImageData(x * pieceSize, y * pieceSize, width, height);
                sliceImages[y][x] = imageData;

                tempCtx.putImageData(imageData, 0, 0);
                tempCtx.fillText((y + 1) + ',' + (x + 1), pieceSize, pieceSize);
                let tempImageURL = tempCanvas.toDataURL("image/png");
                let img = document.getElementById("sliceImage-" + y + "_" + x);
                img.src = tempImageURL;
                img.onclick = function () {
                    currentSliceImage = { x: x, y: y };
                    showImageView(sliceImages[y][x]);
                };
            }
        }
    }

    //生成全图的马赛克视图
    function showFullImageView(keepOffset) {
        currentSliceImage = null;
        let imageData = fullCanvas.getContext('2d').getImageData(0, 0, fullCanvas.width, fullCanvas.height);
        showImageView(imageData, fullCanvas.width, fullCanvas.height, keepOffset);
    }

    //生成指定图像数据马赛克视图
    function showImageView(imageData, keepOffset) {
        //首先绘制在largeCanvas上，再根据偏移坐标绘到viewCanvas
        largeCanvas = document.createElement('canvas');
        let largeCtx = largeCanvas.getContext('2d');

        largeCanvas.width = imageData.width * (pixelSize + 1);
        largeCanvas.height = imageData.height * (pixelSize + 1);
        largeCtx.font = (~~(pixelSize / 2) + 1) + 'px monospace';
        largeCtx.strokeStyle = '#000';
        largeCtx.textBaseline = 'middle';
        largeCtx.textAlign = 'center';

        //绘制标尺
        drawRulers(imageData.width, imageData.height);

        //绘制网格
        largeCtx.beginPath();
        for (let x = 1; x < imageData.width; x++) {
            largeCtx.moveTo(x * (pixelSize + 1) - 0.5, 0);
            largeCtx.lineTo(x * (pixelSize + 1) - 0.5, largeCanvas.height);
            largeCtx.stroke();
        }
        for (let y = 1; y < imageData.height; y++) {
            largeCtx.moveTo(0, y * (pixelSize + 1) - 0.5);
            largeCtx.lineTo(largeCanvas.width, y * (pixelSize + 1) - 0.5);
            largeCtx.stroke();
        }

        //逐像素读取原图并绘制大图
        let colorSum = new Map();//大图颜色统计
        let totolBeadCount = 0;//总拼豆数
        for (let i = 0; i < imageData.data.length; i += 4) {

            //读取颜色，如果透明则跳过
            let a = imageData.data[i + 3];
            if (a == 0) continue;

            let r = imageData.data[i];
            let g = imageData.data[i + 1];
            let b = imageData.data[i + 2];
            let hex = rgbToHex(r, g, b);

            //计算坐标
            let x = (i / 4) % imageData.width;
            let y = ~~((i / 4) / imageData.width);
            // let realPosition = getRealPosition(x, y);

            // //检查像素替换颜色
            // if (pixelColorReplaceList.has(realPosition.x + ',' + realPosition.y)) {
            //     let replaceColor = pixelColorReplaceList.get(realPosition.x + ',' + realPosition.y).new;
            //     let replaceColorRgb = hexToRgb(replaceColor);
            //     hex = replaceColor;
            //     r = replaceColorRgb.r;
            //     g = replaceColorRgb.g;
            //     b = replaceColorRgb.b;
            // }
            // //检查替换颜色
            // else if (colorReplaceList.has(hex)) {
            //     let replaceColor = colorReplaceList.get(hex);
            //     let replaceColorRgb = hexToRgb(replaceColor);
            //     hex = replaceColor;
            //     r = replaceColorRgb.r;
            //     g = replaceColorRgb.g;
            //     b = replaceColorRgb.b;
            // }

            // if (filterColor && filterColor != hex) continue;//如果启用过滤颜色则只显示此颜色

            totolBeadCount++;

            //绘制大像素块
            largeCtx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
            largeCtx.fillRect(x * (pixelSize + 1), y * (pixelSize + 1), pixelSize, pixelSize);

            //写文字
            largeCtx.fillStyle = getFontColor(r, g, b);//浅色黑字，深色白字

            //统计颜色或出错信息
            let color = paletteMap.get(hex);
            if (color) {
                let key = color.name + '#' + rgbToHex(r, g, b);//统计键值包含了名称和颜色
                if (colorSum.has(key)) colorSum.set(key, colorSum.get(key) + 1);
                else colorSum.set(key, 1);
            }
            else {
                console.log('Error color: ' + rgbToHex(r, g, b));
                if (colorSum.has('Err')) colorSum.set('Err', colorSum.get('Err') + 1);
                else colorSum.set('Err', 1);
            }
            largeCtx.fillText(color ? color.name : 'Err', x * (pixelSize + 1) + ~~(pixelSize * 0.5), y * (pixelSize + 1) + ~~(pixelSize * 0.5));
        }

        if (!keepOffset) {//保持拖拽偏移量不变（刷新时用）
            largeCanvasStartOffsetX = 0, largeCanvasStartOffsetY = 0;
            largeCanvasOffsetX = 0, largeCanvasOffsetY = 0;
        }
        //绘制部分图像到viewCanvas
        showPartView();

        //按颜色数量递减排序并显示在颜色统计框
        let colorSumSorted = new Map([...colorSum.entries()].sort(function (a, b) {
            return b[1] - a[1];
        }));

        let sumHtml = '';
        for (let [color, count] of colorSumSorted) {
            //color键分两部分：名称逗号色值
            sumHtml += '<tr><td style="background:#' + color.split('#')[1] + '"> </td><td>' + color.split('#')[0] + '</td><td>' + count + '</td></tr>';
        }
        document.getElementById('colorSumTable').innerHTML = sumHtml;

        let infoHtml = currentSliceImage ?
            "第" + (currentSliceImage.y + 1) + "行第" + (currentSliceImage.x + 1) + "列的图块(" + pieceSize + "x" + pieceSize + ")"
            : "全图(" + fullCanvas.width + "x" + fullCanvas.height + ")";
        if (filterColor) infoHtml += ",只显示颜色" + paletteMap.get(filterColor).name + ",#" + filterColor;
        infoHtml += "," + totolBeadCount + "颗";
        //显示大图摘要说明
        document.getElementById('largePicInfo').innerHTML = infoHtml;
    }

    //将大图的一部分绘制到视图
    function showPartView() {
        if (isDrawingViewCanvas) return;
        isDrawingViewCanvas = true;
        let largeCtx = largeCanvas.getContext('2d'),
            viewCtx = viewCanvas.getContext('2d');

        //重绘后重新计算一次尺寸，避免滚动条影响宽度，使canvas的width和实际宽度不一致
        viewCanvas.width = viewCanvas.clientWidth, viewCanvas.height = viewCanvas.clientWidth;
        //切图时要计算两边的标尺长度
        let viewImageData = largeCtx.getImageData(largeCanvasOffsetX, largeCanvasOffsetY, viewCanvas.width - 2 * (pixelSize + 1), viewCanvas.height - 2 * (pixelSize + 1));
        viewCtx.putImageData(viewImageData, pixelSize + 1, pixelSize + 1);
        //显示局部标尺
        showPartRulers();
        isDrawingViewCanvas = false;
    }

    //绘制完整标尺
    function drawRulers(width, height) {
        //初始化四块标尺画布
        rulerX1Canvas = document.createElement('canvas'), rulerX2Canvas = document.createElement('canvas');
        rulerY1Canvas = document.createElement('canvas'), rulerY2Canvas = document.createElement('canvas');
        rulerX1Canvas.width = width * (pixelSize + 1), rulerX1Canvas.height = pixelSize + 1;
        rulerX2Canvas.width = width * (pixelSize + 1), rulerX2Canvas.height = pixelSize + 1;
        rulerY1Canvas.width = pixelSize + 1, rulerY1Canvas.height = height * (pixelSize + 1);
        rulerY2Canvas.width = pixelSize + 1, rulerY2Canvas.height = height * (pixelSize + 1);
        let rulerX1Ctx = rulerX1Canvas.getContext('2d'), rulerX2Ctx = rulerX2Canvas.getContext('2d'),
            rulerY1Ctx = rulerY1Canvas.getContext('2d'), rulerY2Ctx = rulerY2Canvas.getContext('2d');
        rulerX1Ctx.fillStyle = '#000';
        rulerX1Ctx.strokeStyle = '#000';
        rulerX1Ctx.font = (~~(pixelSize / 2) + 2) + 'px monospace';
        rulerX1Ctx.textBaseline = 'middle';
        rulerX1Ctx.textAlign = 'center';
        rulerX2Ctx.fillStyle = '#000';
        rulerX2Ctx.strokeStyle = '#000';
        rulerX2Ctx.font = (~~(pixelSize / 2) + 2) + 'px monospace';
        rulerX2Ctx.textBaseline = 'middle';
        rulerX2Ctx.textAlign = 'center';
        rulerY1Ctx.fillStyle = '#000';
        rulerY1Ctx.strokeStyle = '#000';
        rulerY1Ctx.font = (~~(pixelSize / 2) + 2) + 'px monospace';
        rulerY1Ctx.textBaseline = 'middle';
        rulerY1Ctx.textAlign = 'center';
        rulerY2Ctx.fillStyle = '#000';
        rulerY2Ctx.strokeStyle = '#000';
        rulerY2Ctx.font = (~~(pixelSize / 2) + 2) + 'px monospace';
        rulerY2Ctx.textBaseline = 'middle';
        rulerY2Ctx.textAlign = 'center';

        //横坐标绘制半竖线和文字
        rulerX1Ctx.beginPath();
        rulerX2Ctx.beginPath();
        for (let x = 0; x <= width; x++) {
            //比实际尺寸减0.5像素是由于canvas的绘图方式，防止出现半像素
            rulerX1Ctx.moveTo(x * (pixelSize + 1) - 0.5, ~~(pixelSize * 0.5) - 0.5);
            rulerX1Ctx.lineTo(x * (pixelSize + 1) - 0.5, pixelSize + 1 - 0.5);
            rulerX1Ctx.stroke();
            rulerX2Ctx.moveTo(x * (pixelSize + 1) - 0.5, - 0.5);
            rulerX2Ctx.lineTo(x * (pixelSize + 1) - 0.5, ~~(pixelSize * 0.5) - 0.5);
            rulerX2Ctx.stroke();
            //绘制标尺文字
            if (x < width) {
                rulerX1Ctx.fillText(x + 1, x * (pixelSize + 1) + ~~(pixelSize * 0.5), ~~(pixelSize * 0.5));
                rulerX2Ctx.fillText(x + 1, x * (pixelSize + 1) + ~~(pixelSize * 0.5), ~~(pixelSize * 0.5));
            }
        }
        //纵坐标绘制横竖线和文字
        rulerY1Ctx.beginPath();
        rulerY2Ctx.beginPath();
        for (let y = 0; y <= height; y++) {//横线
            rulerY1Ctx.moveTo(~~(pixelSize * 0.5) - 0.5, y * (pixelSize + 1) - 0.5);
            rulerY1Ctx.lineTo(pixelSize + 1 - 0.5, y * (pixelSize + 1) - 0.5);
            rulerY1Ctx.stroke();
            rulerY2Ctx.moveTo(~~(pixelSize * 0.5) - 0.5, y * (pixelSize + 1) - 0.5);
            rulerY2Ctx.lineTo(- 0.5, y * (pixelSize + 1) - 0.5);
            rulerY2Ctx.stroke();
            if (y < height) {
                rulerY1Ctx.fillText(y + 1, ~~(pixelSize * 0.5), y * (pixelSize + 1) + ~~(pixelSize * 0.5));
                rulerY2Ctx.fillText(y + 1, ~~(pixelSize * 0.5), y * (pixelSize + 1) + ~~(pixelSize * 0.5));
            }
        }
    }

    //将完整标尺的一部分绘制到视图四边
    function showPartRulers() {
        let viewCtx = viewCanvas.getContext('2d'),
            rulerX1Ctx = rulerX1Canvas.getContext('2d'), rulerX2Ctx = rulerX2Canvas.getContext('2d'),
            rulerY1Ctx = rulerY1Canvas.getContext('2d'), rulerY2Ctx = rulerY2Canvas.getContext('2d');
        //绘制上横标尺
        viewCtx.putImageData(rulerX1Ctx.getImageData(largeCanvasOffsetX, 0, viewCanvas.width - 2 * (pixelSize + 1), pixelSize + 1), pixelSize + 1, 0);
        //绘制下横标尺
        viewCtx.putImageData(rulerX2Ctx.getImageData(largeCanvasOffsetX, 0, viewCanvas.width - 2 * (pixelSize + 1), pixelSize + 1), pixelSize + 1, viewCanvas.height - pixelSize - 1);
        //绘制左竖标尺
        viewCtx.putImageData(rulerY1Ctx.getImageData(0, largeCanvasOffsetY, pixelSize + 1, viewCanvas.height - 2 * (pixelSize + 1)), 0, pixelSize + 1);
        //绘制右竖标尺
        viewCtx.putImageData(rulerY2Ctx.getImageData(0, largeCanvasOffsetY, pixelSize + 1, viewCanvas.height - 2 * (pixelSize + 1)), viewCanvas.width - pixelSize - 1, pixelSize + 1);
        //绘制四条标尺边线
        viewCtx.beginPath();
        viewCtx.moveTo(0, pixelSize + 1 - 0.5);
        viewCtx.lineTo(viewCanvas.width, pixelSize + 1 - 0.5);
        viewCtx.stroke();
        viewCtx.moveTo(0, viewCanvas.height - (pixelSize + 1) - 0.5);
        viewCtx.lineTo(viewCanvas.width, viewCanvas.height - (pixelSize + 1) - 0.5);
        viewCtx.stroke();
        viewCtx.moveTo(pixelSize + 1 - 0.5, 0);
        viewCtx.lineTo(pixelSize + 1 - 0.5, viewCanvas.height);
        viewCtx.stroke();
        viewCtx.moveTo(viewCanvas.width - (pixelSize + 1) - 0.5, 0);
        viewCtx.lineTo(viewCanvas.width - (pixelSize + 1) - 0.5, viewCanvas.height);
        viewCtx.stroke();
    }

    //刷新图片（修改显示像素或者替换颜色之后，保持当前视角不变进行刷新）
    function refreshImage() {
        let ctx = fullCanvas.getContext('2d'),
            newImageData = ctx.createImageData(paletteImageData);//新建一份原尺寸的透明图形数据

        //逐像素读取替换调色板后的原图
        for (let i = 0; i < paletteImageData.data.length; i += 4) {
            //如果透明则跳过
            let a = paletteImageData.data[i + 3];
            if (a == 0) continue;

            //获取颜色值
            let r = paletteImageData.data[i];
            let g = paletteImageData.data[i + 1];
            let b = paletteImageData.data[i + 2];
            let hex = rgbToHex(r, g, b);

            //计算坐标
            let x = (i / 4) % paletteImageData.width;
            let y = ~~((i / 4) / paletteImageData.width);

            //检查像素替换颜色
            if (pixelColorReplaceList.has(x + ',' + y)) {
                let replaceColor = pixelColorReplaceList.get(x + ',' + y).new;
                let replaceColorRgb = hexToRgb(replaceColor);
                hex = replaceColor;
                r = replaceColorRgb.r;
                g = replaceColorRgb.g;
                b = replaceColorRgb.b;
            }
            //检查替换颜色
            else if (colorReplaceList.has(hex)) {
                let replaceColor = colorReplaceList.get(hex);
                let replaceColorRgb = hexToRgb(replaceColor);
                hex = replaceColor;
                r = replaceColorRgb.r;
                g = replaceColorRgb.g;
                b = replaceColorRgb.b;
            }

            //如果启用过滤颜色则只显示此颜色
            if (filterColor && filterColor != hex) continue;

            //设置新图像素点
            newImageData.data[i] = r;
            newImageData.data[i + 1] = g;
            newImageData.data[i + 2] = b;
            newImageData.data[i + 3] = 255;//处理后一律变成不透明色
        }

        //绘制过滤替换后的新图
        ctx.putImageData(newImageData, 0, 0);

        //将完整图片切成图块
        sliceCanvasToImage(fullCanvas, 'sliceImageContainer');

        //根据当前显示的是全图或图块显示视图
        if (!currentSliceImage) {
            showFullImageView(true);
        }
        else {
            showImageView(sliceImages[currentSliceImage.y][currentSliceImage.x], pieceSize, pieceSize, true);
        }
    }

    //刷新颜色替换列表
    function refreshColorReplaceList() {
        let pixelColorReplaceHtml = '';
        for (let [position, colors] of pixelColorReplaceList) {
            pixelColorReplaceHtml += '<tr><td>' + position + '</td>';
            pixelColorReplaceHtml += '<td style="background:#' + colors.old + ';color:' + getFontColor(colors.old) + ';">' + paletteMap.get(colors.old).name + '</td>';
            pixelColorReplaceHtml += '<td style="background:#' + colors.new + ';color:' + getFontColor(colors.new) + ';">' + paletteMap.get(colors.new).name + '</td>';
            pixelColorReplaceHtml += '<td><button type="button" class="btn btn-danger btn-sm remove-pixel-color-replace" value=' + position + '>删除</button></td></tr>';
        }
        document.getElementById('pixelColorReplaceTable').innerHTML = pixelColorReplaceHtml;

        let colorReplaceHtml = '';
        for (let [oldColor, newColor] of colorReplaceList) {
            colorReplaceHtml += '<tr><td style="background:#' + oldColor + ';color:' + getFontColor(oldColor) + ';">' + paletteMap.get(oldColor).name + '</td>';
            colorReplaceHtml += '<td style="background:#' + newColor + ';color:' + getFontColor(newColor) + ';">' + paletteMap.get(newColor).name + '</td>';
            colorReplaceHtml += '<td><button type="button" class="btn btn-danger btn-sm remove-color-replace" value=' + oldColor + '>删除</button></td></tr>';
        }
        document.getElementById('colorReplaceTable').innerHTML = colorReplaceHtml;

        //绑定删除按钮点击事件
        $(".remove-color-replace").click(function () {
            let color = $(this).attr('value');
            if (colorReplaceList.has(color)) {
                colorReplaceList.delete(color);
                refreshColorReplaceList();
                refreshImage();
            }
        });
        $(".remove-pixel-color-replace").click(function () {
            let position = $(this).attr('value');
            if (pixelColorReplaceList.has(position)) {
                pixelColorReplaceList.delete(position);
                refreshColorReplaceList();
                refreshImage();
            }

        });
    }

    //使用切块坐标获取在全图中的真实坐标
    function getRealPosition(x, y) {
        //如果显示的是全图则直接返回原始坐标
        if (!currentSliceImage) {
            return { x: x, y: y };
        }
        //否则根据切块位置计算真实坐标
        else {
            return {
                x: x + currentSliceImage.x * pieceSize,
                y: y + currentSliceImage.y * pieceSize
            };
        }
    }

    //使用真实坐标获取在切块中的坐标
    function getSlicePosition(x, y) {
        //如果显示的是全图则直接返回原始坐标
        if (!currentSliceImage) {
            return { x: x, y: y };
        }
        //否则通过真实坐标计算当前切块中的坐标
        else {
            return {
                x: x - currentSliceImage.x * pieceSize,
                y: y - currentSliceImage.y * pieceSize
            };
        }
    }

    //寻找一个颜色最相近的调色板色值
    function findSimilarColor(r, g, b) {
        let hex = rgbToHex(r, g, b);
        //首先查找缓存
        if (similarColorCache.has(hex)) {
            return similarColorCache.get(hex);
        }

        let minDistance = 584970;//最小色差值（初始值为纯黑和纯白的色差，使用colorDistance(0,0,0,255,255,255)计算而得）
        let minColor = null;//最小值对应的颜色
        for (let color of paletteMap.values()) {
            let distance = colorDistance(color.r, color.g, color.b, r, g, b);
            if (distance == 0) {//颜色相等直接返回
                similarColorCache.set(hex, color);//写入缓存
                return color;
            }
            if (distance < minDistance) {
                minDistance = distance;
                minColor = color;
            }
        }

        similarColorCache.set(hex, minColor);//写入缓存
        return minColor;
    }

    //调色板数据生成动态对象以便查询
    function generatePaletteMap(palette) {
        let map = new Map();
        for (let i = 0; i < palette.length; i++) {
            let rgb = hexToRgb(palette[i].color);
            map.set(palette[i].color, {
                name: palette[i].name,
                r: rgb.r,
                g: rgb.g,
                b: rgb.b
            });
        }
        return map;
    }

    //十六进制颜色转rgb数值
    function hexToRgb(hex) {
        let result = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
        } : null;
    }

    //rgb数值转十六进制颜色
    function rgbToHex(r, g, b) {
        let rhex = r.toString(16),
            ghex = g.toString(16),
            bhex = b.toString(16);
        return (rhex.length == 1 ? "0" + rhex : rhex) + (ghex.length == 1 ? "0" + ghex : ghex) + (bhex.length == 1 ? "0" + bhex : bhex);
    }

    //根据背景颜色获取可视的字体颜色（传入rgb或16进制颜色均可，返回16进制颜色）
    function getFontColor(arg1, arg2, arg3) {
        if (typeof arg1 == 'string' && arg1.length == 6) {
            let rgb = hexToRgb(arg1);
            return rgb.r + rgb.g + rgb.b > 384 ? '#000' : '#FFF';//浅色黑字，深色白字
        } else if (typeof arg1 == 'number' && typeof arg2 == 'number' && typeof arg2 == 'number') {
            return arg1 + arg2 + arg2 > 384 ? '#000' : '#FFF';
        }
        else
            return null;
    }

    //颜色差别公式，简化版，参考https://stackoverflow.com/a/9085524
    function colorDistance(r1, g1, b1, r2, g2, b2) {
        let rmean = (r1 + r2) / 2,
            rd = r1 - r2,
            gd = g1 - g2,
            bd = b1 - b2;
        return (((512 + rmean) * rd * rd) >> 8) + 4 * gd * gd + (((767 - rmean) * bd * bd) >> 8);
    }
</script>

</html>