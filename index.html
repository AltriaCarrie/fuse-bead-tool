<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>拼豆图片生成器</title>
    <link rel="stylesheet" href="bootstrap-4.3.1/css/bootstrap.min.css">
    <link href="css/style.css" rel="stylesheet">
    <script src="js/palette.js"></script>
</head>

<body>
    <div class="card">
        <div class="card-header">
            上传图片
        </div>
        <div class="card-body">
            <input type="file" id="imageChooser" accept="image/png, image/jpeg, image/gif" />
        </div>
    </div>
    <div class="row">
        <div class="col">
            <div class="card">
                <div class="card-header">
                    原始图片
                </div>
                <div class="card-body">
                    <canvas id="originalCanvas"></canvas>
                </div>
            </div>
        </div>
        <div class="col">
            <div class="card">
                <div class="card-header">
                    换色图片
                </div>
                <div class="card-body">
                    <canvas id="paletteCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>
    <div class="card">
        <div class="card-header">
            图片切块
        </div>
        <div class="card-body">
            <table id='sliceImageContainer' class='table-bordered'>
            </table>
            <button id='showFullImageButton' class="btn btn-light btn-block">显示全图</button>
        </div>
    </div>
    </div>
    <div class="card">
        <div class="card-header">
            <button class="btn btn-link" data-toggle="collapse" data-target="#collapseColorSum" aria-expanded="false"
                aria-controls="collapseColorSum">
                颜色统计
            </button>
        </div>
        <div id="collapseColorSum" class="card-collapse collapse">
            <div class="card-body" id="colorSum"></div>
        </div>
    </div>
    <canvas id="largeCanvas"></canvas>
</body>

<script type="text/javascript">
    var pixelSize = 20,//马赛克像素尺寸（放大倍数）
        pieceSize = 48,//单块拼板容纳的拼豆数
        paletteMap = generatePaletteMap(samplePalette),//调色板对象集合
        similarColorCache = new Map(),//与实际颜色最相近的调色板颜色缓存
        fullPicData = new Array();//存储全图的数组

    var onLoad = function () {
        var originalCanvas = document.getElementById('originalCanvas'),//原始图片canvas
            originalCtx = originalCanvas.getContext('2d'),
            paletteCanvas = document.getElementById('paletteCanvas'),//调色板预处理图片canvas
            paletteCtx = paletteCanvas.getContext('2d'),
            largeCanvas = document.getElementById('largeCanvas'),//大图canvas
            largeCtx = largeCanvas.getContext('2d');
        originalCanvas.width = 0, originalCanvas.height = 0;
        paletteCanvas.width = 0, paletteCanvas.height = 0;
        largeCanvas.width = 0, largeCanvas.height = 0;

        let imageChooser = document.getElementById('imageChooser');
        imageChooser.onchange = function (e) {
            if (e.target.files.length <= 0) return;
            let imageFile = e.target.files[0];
            var reader = new FileReader();
            reader.onload = function (e) {
                originalCtx.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
                var image = new Image();
                image.src = e.target.result;
                image.onload = function (e) {
                    //重加载图片后清空缓存与大图数据
                    similarColorCache = new Map();
                    fullPicData = new Array();

                    originalCanvas.width = this.width;
                    originalCanvas.height = this.height;
                    originalCtx.drawImage(this, 0, 0);
                    trimCanvas(originalCanvas);
                    toPaletteColor(originalCanvas, paletteCanvas);
                    sliceCanvasToImage(paletteCanvas);

                    showFullLargeImage(paletteCanvas, largeCanvas);
                }
                // 清空图片上传框的值
                imageChooser.value = '';
            };

            reader.readAsDataURL(imageFile);
        };

        document.getElementById('showFullImageButton').onclick = function (e) {
            showFullLargeImage(paletteCanvas, largeCanvas);
        };
    };

    //去除canvas边缘的透明和白色像素
    function trimCanvas(canvas) {
        let ctx = canvas.getContext('2d'),
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height),
            bound = {
                top: null,
                left: null,
                right: null,
                bottom: null
            };

        for (let i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i + 3] !== 0
                && (imageData.data[i] < 250 && imageData.data[i + 1] < 250 && imageData.data[i + 2] < 250)) {//透明或者近似白色都作为白色去掉
                let x = (i / 4) % canvas.width;
                let y = ~~((i / 4) / canvas.width);

                if (bound.top === null) {
                    bound.top = y;
                }

                if (bound.left === null) {
                    bound.left = x;
                } else if (x < bound.left) {
                    bound.left = x;
                }

                if (bound.right === null) {
                    bound.right = x;
                } else if (bound.right < x) {
                    bound.right = x;
                }

                if (bound.bottom === null) {
                    bound.bottom = y;
                } else if (bound.bottom < y) {
                    bound.bottom = y;
                }
            }
        }

        //取出裁剪图片的宽高
        let trimHeight = bound.bottom - bound.top,
            trimWidth = bound.right - bound.left,
            trimmedImage = ctx.getImageData(bound.left, bound.top, trimWidth, trimHeight);

        canvas.width = trimWidth;
        canvas.height = trimHeight;
        ctx.putImageData(trimmedImage, 0, 0);
    }

    //将canvas颜色输出为最相近的调色板颜色
    function toPaletteColor(sourceCanvas, destCanvas) {
        let sourceCtx = sourceCanvas.getContext('2d'),
            destCtx = destCanvas.getContext('2d'),
            imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);

        //逐像素读取原图并寻找颜色值
        for (let i = 0; i < imageData.data.length; i += 4) {
            //读取颜色，如果透明则跳过
            let a = imageData.data[i + 3];
            if (a == 0) continue;

            let r = imageData.data[i];
            let g = imageData.data[i + 1];
            let b = imageData.data[i + 2];

            let x = (i / 4) % sourceCanvas.width;
            let y = ~~((i / 4) / sourceCanvas.width);

            //绘制调色板图
            let similarColor = findSimilarColor(r, g, b);
            imageData.data[i] = similarColor.r;
            imageData.data[i + 1] = similarColor.g;
            imageData.data[i + 2] = similarColor.b;
            imageData.data[i + 3] = 255;//处理后一律变成不透明色
        }

        destCanvas.width = sourceCanvas.width;
        destCanvas.height = sourceCanvas.height;
        destCtx.putImageData(imageData, 0, 0);
    }

    //将canvas分割为小图并输出为可点击的image集合
    function sliceCanvasToImage(canvas) {
        let ctx = canvas.getContext('2d'),
            rowCount = Math.ceil(canvas.height / pieceSize),//分割行数
            colCount = Math.ceil(canvas.width / pieceSize);//分割列数

        //生成table和image标签
        let tableHtml = "";
        for (let y = 0; y < rowCount; y++) {
            tableHtml += "<tr>";
            for (let x = 0; x < colCount; x++) {
                tableHtml += "<td><img id='sliceImage-" + y + "_" + x + "' /></td>";
            }
            tableHtml += "</tr>";
        }
        document.getElementById('sliceImageContainer').innerHTML = tableHtml;

        //生成临时Canvas用于转换分割小图
        let tempCanvas = document.createElement('canvas'),
            tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = pieceSize;
        tempCanvas.height = pieceSize;
        tempCtx.font = ~~(pieceSize / 4) + 'px monospace';
        tempCtx.strokeStyle = '#000';
        tempCtx.textBaseline = 'bottom';
        tempCtx.textAlign = 'right';

        fullPicData = new Array(rowCount);
        for (let y = 0; y < rowCount; y++) {
            fullPicData[y] = new Array(colCount);
            for (let x = 0; x < colCount; x++) {
                tempCtx.clearRect(0, 0, pieceSize, pieceSize);
                //如果宽高超出canvas则减小
                let width = (x + 1 * pieceSize) > canvas.width ? canvas.width - x * pieceSize : pieceSize;
                let height = (y + 1 * pieceSize) > canvas.height ? canvas.height - y * pieceSize : pieceSize;
                let imageData = ctx.getImageData(x * pieceSize, y * pieceSize, width, height);
                fullPicData[y][x] = imageData;

                tempCtx.putImageData(imageData, 0, 0);
                tempCtx.fillText((y + 1) + ',' + (x + 1), pieceSize, pieceSize);
                let tempImageURL = tempCanvas.toDataURL("image/png");
                let img = document.getElementById("sliceImage-" + y + "_" + x);
                img.src = tempImageURL;
                img.onclick = function () { showLargeImage(fullPicData[y][x], width, height, largeCanvas); };
            }
        }
    }

    //生成全图的马赛克大图
    function showFullLargeImage(sourceCanvas, destCanvas) {
        let imageData = sourceCanvas.getContext('2d').getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
        showLargeImage(imageData, sourceCanvas.width, sourceCanvas.height, destCanvas);
    }

    //生成马赛克大图
    function showLargeImage(imageData, width, height, destCanvas) {
        let destCtx = destCanvas.getContext('2d');

        destCanvas.width = (width + 2) * (pixelSize + 1);//+2是留给标尺的空间
        destCanvas.height = (height + 2) * (pixelSize + 1);
        destCtx.font = (~~(pixelSize / 2) + 2) + 'px monospace';
        destCtx.strokeStyle = '#000';
        destCtx.textBaseline = 'middle';
        destCtx.textAlign = 'center';

        //绘制标尺
        destCtx.beginPath();
        destCtx.fillStyle = '#000';
        for (let x = 1; x <= width + 1; x++) {//竖线
            //比实际尺寸减0.5像素是由于canvas的绘图方式，防止出现半像素
            destCtx.moveTo(x * (pixelSize + 1) - 0.5, ~~(pixelSize * 0.5) - 0.5);
            destCtx.lineTo(x * (pixelSize + 1) - 0.5, ~~(destCanvas.height - pixelSize * 0.5) - 0.5);
            destCtx.stroke();
            //绘制标尺文字
            if (x < width + 1) {
                destCtx.fillText(x, x * (pixelSize + 1) + ~~(pixelSize * 0.5), ~~(pixelSize * 0.5));
                destCtx.fillText(x, x * (pixelSize + 1) + ~~(pixelSize * 0.5), ~~(destCanvas.height - pixelSize * 0.5));
            }
        }
        for (let y = 1; y <= height + 1; y++) {//横线
            destCtx.moveTo(~~(pixelSize * 0.5) - 0.5, y * (pixelSize + 1) - 0.5);
            destCtx.lineTo(~~(destCanvas.width - pixelSize * 0.5) - 0.5, y * (pixelSize + 1) - 0.5);
            destCtx.stroke();
            if (y < height + 1) {
                destCtx.fillText(y, ~~(pixelSize * 0.5), y * (pixelSize + 1) + ~~(pixelSize * 0.5));
                destCtx.fillText(y, ~~(destCanvas.width - pixelSize * 0.5), y * (pixelSize + 1) + ~~(pixelSize * 0.5));
            }
        }

        let colorSum = new Map();//大图颜色统计
        let totolBeadCount = 0;//总拼豆数
        //逐像素读取原图并绘制大图
        for (let i = 0; i < imageData.data.length; i += 4) {
            //绘制边框（只有右边和下边）
            let x = (i / 4) % width;
            let y = ~~((i / 4) / width);

            //读取颜色，如果透明则跳过
            let a = imageData.data[i + 3];
            if (a == 0) continue;

            totolBeadCount++;

            let r = imageData.data[i];
            let g = imageData.data[i + 1];
            let b = imageData.data[i + 2];

            //绘制大像素块
            destCtx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
            destCtx.fillRect((x + 1) * (pixelSize + 1), (y + 1) * (pixelSize + 1), pixelSize, pixelSize);

            //写文字
            destCtx.fillStyle = r + g + b > 384 ? '#000' : '#FFF';//浅色黑字，深色白字
            let color = paletteMap.get(rgbToHex(r, g, b));
            //统计颜色或出错信息
            if (color) {
                let key = color.name + '#' + rgbToHex(r, g, b);//统计键值包含了名称和颜色
                if (colorSum.has(key)) colorSum.set(key, colorSum.get(key) + 1);
                else colorSum.set(key, 1);
            }
            else {
                console.log('Error color: ' + rgbToHex(r, g, b));
                if (colorSum.has('Err')) colorSum.set('Err', colorSum.get('Err') + 1);
                else colorSum.set('Err', 1);
            }
            destCtx.fillText(color ? color.name : 'Err', (x + 1) * (pixelSize + 1) + ~~(pixelSize * 0.5), (y + 1) * (pixelSize + 1) + ~~(pixelSize * 0.5));
        }

        //按颜色数量递减排序
        let colorSumSorted = new Map([...colorSum.entries()].sort(function (a, b) {
            return b[1] - a[1];
        }));

        let sumHtml = '<table class="table"><thead><th> </th><th>颜色</th><th>数量</th></thead><tbody>';
        sumHtml += '<tr><td></td><td>总计</td><td>' + totolBeadCount + '</td></tr>';
        for (let [color, count] of colorSumSorted) {
            //color键分两部分：名称逗号色值
            sumHtml += '<tr><td style="width: 20px; background:#' + color.split('#')[1] + '"> </td><td>' + color.split('#')[0] + '</td><td>' + count + '</td></tr>';
        }
        sumHtml += '</tbody></table>';
        document.getElementById('colorSum').innerHTML = sumHtml;
    }

    //寻找一个颜色最相近的调色板色值
    function findSimilarColor(r, g, b) {
        let hex = rgbToHex(r, g, b);
        //首先查找缓存
        if (similarColorCache.has(hex)) {
            return similarColorCache.get(hex);
        }

        let minDistance = 584970;//最小色差值（初始值为纯黑和纯白的色差，使用colorDistance(0,0,0,255,255,255)计算而得）
        let minColor = null;//最小值对应的颜色
        for (let color of paletteMap.values()) {
            let distance = colorDistance(color.r, color.g, color.b, r, g, b);
            if (distance == 0) {//颜色相等直接返回
                similarColorCache.set(hex, color);//写入缓存
                return color;
            }
            if (distance < minDistance) {
                minDistance = distance;
                minColor = color;
            }
        }

        similarColorCache.set(hex, minColor);//写入缓存
        return minColor;
    }

    //调色板数据生成动态对象以便查询
    function generatePaletteMap(palette) {
        let map = new Map();
        for (let i = 0; i < palette.length; i++) {
            let rgb = hexToRgb(palette[i].color);
            map.set(palette[i].color, {
                name: palette[i].name,
                r: rgb.r,
                g: rgb.g,
                b: rgb.b
            });
        }
        return map;
    }

    //十六进制颜色转rgb数值
    function hexToRgb(hex) {
        let result = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
        } : null;
    }

    //rgb数值转十六进制颜色
    function rgbToHex(r, g, b) {
        let rhex = r.toString(16),
            ghex = g.toString(16),
            bhex = b.toString(16);
        return (rhex.length == 1 ? "0" + rhex : rhex) + (ghex.length == 1 ? "0" + ghex : ghex) + (bhex.length == 1 ? "0" + bhex : bhex);
    }

    //颜色差别公式，简化版，参考https://stackoverflow.com/a/9085524
    function colorDistance(r1, g1, b1, r2, g2, b2) {
        let rmean = (r1 + r2) / 2,
            rd = r1 - r2,
            gd = g1 - g2,
            bd = b1 - b2;
        return (((512 + rmean) * rd * rd) >> 8) + 4 * gd * gd + (((767 - rmean) * bd * bd) >> 8);
    }

    //原生js实现jQuery的ready，详见https://www.sitepoint.com/jquery-document-ready-plain-javascript/
    if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
        onLoad();
    } else {
        document.addEventListener("DOMContentLoaded", onLoad);
    }
</script>
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
<script src="js/popper.min.js"></script>
<script src='bootstrap-4.3.1/js/bootstrap.min.js'></script>

</html>