<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>拼豆图片生成器</title>
    <link rel="stylesheet" href="bootstrap-4.3.1/css/bootstrap.min.css">
    <link href="css/style.css" rel="stylesheet">
    <script src="js/palette.js"></script>
</head>

<body>
    <div class="card">
        <div class="card-header">
            上传图片
        </div>
        <div class="card-body">
            <input type="file" id="imageChooser" accept="image/png, image/jpeg, image/gif" />
        </div>
    </div>
    <div class="row">
        <div class="col">
            <div class="card">
                <div class="card-header">
                    原始图片
                </div>
                <div class="card-body">
                    <canvas id="originalCanvas"></canvas>
                </div>
            </div>
        </div>
        <div class="col">
            <div class="card">
                <div class="card-header">
                    换色图片
                </div>
                <div class="card-body">
                    <canvas id="paletteCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>
    <div class="card">
        <div class="card-header">
            图片切块
        </div>
        <div class="card-body">
            <table id='sliceImageContainer' class='table-bordered'>
            </table>
            <button id='showFullImageButton' class="btn btn-light btn-block">显示全图</button>
        </div>
    </div>
    </div>
    <div class="card">
        <div class="card-header">
            <button class="btn btn-link" data-toggle="collapse" data-target="#collapseColorSum" aria-expanded="false"
                aria-controls="collapseColorSum">
                颜色统计▼
            </button>
        </div>
        <div id="collapseColorSum" class="card-collapse collapse">
            <div class="card-body" id="colorSum"></div>
        </div>
    </div>
    <div class="card">
        <div class="card-header">
            大图显示
        </div>
        <div class="card-body">
            <canvas id="largeCanvas" style='width: 100%;'></canvas>
        </div>
    </div>
    <div class="modal fade" id="colorModal" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">颜色处理</h5>
                </div>
                <div class="modal-body ">
                    <div class="container-fluid">
                        1
                        <hr />
                        2
                        <hr />
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>

<script type="text/javascript">
    var pixelSize = 20,//马赛克像素尺寸（放大倍数）
        pieceSize = 48,//单块拼板容纳的拼豆数
        paletteMap = generatePaletteMap(samplePalette),//调色板对象集合
        similarColorCache = new Map(),//与实际颜色最相近的调色板颜色缓存
        fullPicData = new Array(),//存储全图的数组
        currentSlicePic = { x: -1, y: -1 };//当前大图显示的切块坐标（如果是全图则为-1,-1）

    var isDragging = false,//大图canvas是否正在拖拽中
        startDragX = 0,//拖拽起点X
        startDragY = 0,//拖拽起点Y
        filterColor = '';//颜色筛选（只显示此颜色的色块）

    var backgroundLargeCanvas,//背景大图Canvas，切出一部分显示在LargeCanvas
        backgroundCanvasStartOffsetX = 0,//拖拽开始时的背景X坐标偏移
        backgroundCanvasStartOffsetY = 0,//拖拽开始时的背景Y坐标偏移
        backgroundCanvasOffsetX = 0,//背景大图的X坐标偏移
        backgroundCanvasOffsetY = 0,//背景大图的Y坐标偏移
        isDrawingLargeCanvas = false;//大图是否正在重绘中

    var rulerX1Canvas, rulerX2Canvas, rulerY1Canvas, rulerY2Canvas;//四个标尺的canvas

    var onLoad = function () {
        var originalCanvas = document.getElementById('originalCanvas'),//原始图片canvas            
            paletteCanvas = document.getElementById('paletteCanvas'),//调色板预处理图片canvas
            largeCanvas = document.getElementById('largeCanvas');//大图canvas
        originalCanvas.width = 0, originalCanvas.height = 0;
        paletteCanvas.width = 0, paletteCanvas.height = 0;
        largeCanvas.width = largeCanvas.clientWidth, largeCanvas.height = largeCanvas.clientWidth;
        //窗口重绘后重设canvas尺寸
        window.addEventListener('resize', function (e) {
            largeCanvas.width = largeCanvas.clientWidth, largeCanvas.height = largeCanvas.clientWidth;
        }, false);

        let imageChooser = document.getElementById('imageChooser');
        imageChooser.onchange = function (e) {
            if (e.target.files.length <= 0) return;
            let imageFile = e.target.files[0];
            var reader = new FileReader();
            reader.onload = function (e) {
                originalCtx = originalCanvas.getContext('2d');
                originalCtx.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
                var image = new Image();
                image.src = e.target.result;
                image.onload = function (e) {
                    //重加载图片后清空缓存与大图数据
                    similarColorCache = new Map();
                    fullPicData = new Array();

                    originalCanvas.width = this.width;
                    originalCanvas.height = this.height;
                    originalCtx.drawImage(this, 0, 0);
                    trimCanvas(originalCanvas);
                    toPaletteColor(originalCanvas, paletteCanvas);
                    sliceCanvasToImage(paletteCanvas);

                    showFullLargeImage(paletteCanvas);
                }
                // 清空图片上传框的值
                imageChooser.value = '';
            };

            reader.readAsDataURL(imageFile);
        };

        document.getElementById('showFullImageButton').onclick = function (e) {
            showFullLargeImage(paletteCanvas);
        };

        //大图鼠标和触摸事件
        {
            largeCanvas.onmousedown = function (e) {
                if (e.buttons == 1 && backgroundLargeCanvas) {//点击左键并且在大图已加载情况下开始拖拽
                    startDragX = e.clientX;
                    startDragY = e.clientY;
                    isDragging = true;
                }
            };
            largeCanvas.onmousemove = function (e) {
                if (isDragging && !isDrawingLargeCanvas) {
                    //计算大图偏移值
                    backgroundCanvasOffsetX = backgroundCanvasStartOffsetX + startDragX - e.clientX;
                    backgroundCanvasOffsetY = backgroundCanvasStartOffsetY + startDragY - e.clientY;
                    if (backgroundCanvasOffsetX > backgroundLargeCanvas.width - largeCanvas.width) backgroundCanvasOffsetX = backgroundLargeCanvas.width - largeCanvas.width;
                    if (backgroundCanvasOffsetX < 0) backgroundCanvasOffsetX = 0;
                    if (backgroundCanvasOffsetY > backgroundLargeCanvas.height - largeCanvas.height) backgroundCanvasOffsetY = backgroundLargeCanvas.height - largeCanvas.height;
                    if (backgroundCanvasOffsetY < 0) backgroundCanvasOffsetY = 0;
                    requestAnimationFrame(function () {
                        showPartLargeCanvas();
                    });
                }
            };
            largeCanvas.onmouseup = function (e) {
                if (isDragging) {
                    if (e.clientX == startDragX && e.clientY == startDragY) {//如果未移动则触发点击事件
                        largeCanvasClick(e);
                    }
                    isDragging = false;
                    backgroundCanvasStartOffsetX = backgroundCanvasOffsetX;
                    backgroundCanvasStartOffsetY = backgroundCanvasOffsetY;
                }
            };
            largeCanvas.onmouseout = function (e) {
                isDragging = false;
                backgroundCanvasStartOffsetX = backgroundCanvasOffsetX;
                backgroundCanvasStartOffsetY = backgroundCanvasOffsetY;
            };

            //触摸事件触发鼠标事件（移动端）
            largeCanvas.ontouchstart = function (e) {
                e.preventDefault();
                let touch = e.touches[0];
                largeCanvas.dispatchEvent(new MouseEvent("mousedown", {
                    buttons: 1,
                    clientX: touch.clientX,
                    clientY: touch.clientY
                }));
            };
            largeCanvas.ontouchmove = function (e) {
                e.preventDefault();
                let touch = e.touches[0];
                largeCanvas.dispatchEvent(new MouseEvent("mousemove", {
                    buttons: 1,
                    clientX: touch.clientX,
                    clientY: touch.clientY
                }));
            };
            largeCanvas.ontouchend = function (e) {
                e.preventDefault();
                let touch = e.changedTouches[0];
                largeCanvas.dispatchEvent(new MouseEvent("mouseup", {
                    buttons: 1,
                    clientX: touch.clientX,
                    clientY: touch.clientY
                }));
            };
            largeCanvas.ontouchcancel = function (e) {
                e.preventDefault();
                largeCanvas.dispatchEvent(new MouseEvent("mouseout", {}));
            };
        }
    };

    //大图点击或触摸事件
    function largeCanvasClick(e) {
        //实际在全图上的点击坐标
        let rect = largeCanvas.getBoundingClientRect();
        let realClickX = e.clientX - rect.left + backgroundCanvasOffsetX - (pixelSize + 1),
            realClickY = e.clientY - rect.top + backgroundCanvasOffsetY - (pixelSize + 1);
        //如果点在标尺上则不触发事件
        if (realClickX < 0 || realClickX > largeCanvas.width + backgroundCanvasOffsetX - 2 * (pixelSize + 1)
            || realClickY < 0 || realClickY > largeCanvas.height + backgroundCanvasOffsetY - 2 * (pixelSize + 1)) return;

        //实际像素坐标
        let pointX = ~~(realClickX / (pixelSize + 1)),
            pointY = ~~(realClickY / (pixelSize + 1));
        let pointColor = getLargeCanvasColor(pointX, pointY);
        //获得调色板颜色
        let color = paletteMap.get(rgbToHex(pointColor.r, pointColor.g, pointColor.b));

        $('#colorModal').modal('show');
    }

    //获取大图指定坐标点对应的图片色值
    function getLargeCanvasColor(x, y) {
        //根据当前显示的是全图还是切块，读取坐标所在rgb数据
        let imageData, cursor;
        if (currentSlicePic && currentSlicePic.x == -1) {
            let ctx = paletteCanvas.getContext('2d');
            imageData = ctx.getImageData(0, 0, paletteCanvas.width, paletteCanvas.height);
            cursor = (y * paletteCanvas.width + x) * 4;
        } else {
            imageData = fullPicData[currentSlicePic.y][currentSlicePic.x];
            cursor = (y * pieceSize + x) * 4;
        }

        if (imageData.data[cursor + 3] == 0) return null;

        return {
            r: imageData.data[cursor],
            g: imageData.data[cursor + 1],
            b: imageData.data[cursor + 2],
        }
    }

    //去除canvas边缘的透明和白色像素
    function trimCanvas(canvas) {
        let ctx = canvas.getContext('2d'),
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height),
            bound = {
                top: null,
                left: null,
                right: null,
                bottom: null
            };

        for (let i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i + 3] !== 0
                && (imageData.data[i] < 250 && imageData.data[i + 1] < 250 && imageData.data[i + 2] < 250)) {//透明或者近似白色都作为白色去掉
                let x = (i / 4) % canvas.width;
                let y = ~~((i / 4) / canvas.width);

                if (bound.top === null) {
                    bound.top = y;
                }

                if (bound.left === null) {
                    bound.left = x;
                } else if (x < bound.left) {
                    bound.left = x;
                }

                if (bound.right === null) {
                    bound.right = x;
                } else if (bound.right < x) {
                    bound.right = x;
                }

                if (bound.bottom === null) {
                    bound.bottom = y;
                } else if (bound.bottom < y) {
                    bound.bottom = y;
                }
            }
        }

        //取出裁剪图片的宽高
        let trimHeight = bound.bottom - bound.top,
            trimWidth = bound.right - bound.left,
            trimmedImage = ctx.getImageData(bound.left, bound.top, trimWidth, trimHeight);

        canvas.width = trimWidth;
        canvas.height = trimHeight;
        ctx.putImageData(trimmedImage, 0, 0);
    }

    //将canvas颜色输出为最相近的调色板颜色
    function toPaletteColor(sourceCanvas, destCanvas) {
        let sourceCtx = sourceCanvas.getContext('2d'),
            destCtx = destCanvas.getContext('2d'),
            imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);

        //逐像素读取原图并寻找颜色值
        for (let i = 0; i < imageData.data.length; i += 4) {
            //读取颜色，如果透明则跳过
            let a = imageData.data[i + 3];
            if (a == 0) continue;

            //加透明度选项
            let r = ~~(imageData.data[i] * a / 255);
            let g = ~~(imageData.data[i + 1] * a / 255);
            let b = ~~(imageData.data[i + 2] * a / 255);

            let x = (i / 4) % sourceCanvas.width;
            let y = ~~((i / 4) / sourceCanvas.width);

            //绘制调色板图
            let similarColor = findSimilarColor(r, g, b);
            imageData.data[i] = similarColor.r;
            imageData.data[i + 1] = similarColor.g;
            imageData.data[i + 2] = similarColor.b;
            imageData.data[i + 3] = 255;//处理后一律变成不透明色
        }

        destCanvas.width = sourceCanvas.width;
        destCanvas.height = sourceCanvas.height;
        destCtx.putImageData(imageData, 0, 0);
    }

    //将canvas分割为小图并输出为可点击的image集合
    function sliceCanvasToImage(canvas) {
        let ctx = canvas.getContext('2d'),
            rowCount = Math.ceil(canvas.height / pieceSize),//分割行数
            colCount = Math.ceil(canvas.width / pieceSize);//分割列数

        //生成table和image标签
        let tableHtml = "";
        for (let y = 0; y < rowCount; y++) {
            tableHtml += "<tr>";
            for (let x = 0; x < colCount; x++) {
                tableHtml += "<td><img id='sliceImage-" + y + "_" + x + "' /></td>";
            }
            tableHtml += "</tr>";
        }
        document.getElementById('sliceImageContainer').innerHTML = tableHtml;

        //生成临时Canvas用于转换分割小图
        let tempCanvas = document.createElement('canvas'),
            tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = pieceSize;
        tempCanvas.height = pieceSize;
        tempCtx.font = ~~(pieceSize / 4) + 'px monospace';
        tempCtx.strokeStyle = '#000';
        tempCtx.textBaseline = 'bottom';
        tempCtx.textAlign = 'right';

        fullPicData = new Array(rowCount);
        for (let y = 0; y < rowCount; y++) {
            fullPicData[y] = new Array(colCount);
            for (let x = 0; x < colCount; x++) {
                tempCtx.clearRect(0, 0, pieceSize, pieceSize);
                //如果宽高超出canvas则减小
                let width = (x + 1 * pieceSize) > canvas.width ? canvas.width - x * pieceSize : pieceSize;
                let height = (y + 1 * pieceSize) > canvas.height ? canvas.height - y * pieceSize : pieceSize;
                let imageData = ctx.getImageData(x * pieceSize, y * pieceSize, width, height);
                fullPicData[y][x] = imageData;

                tempCtx.putImageData(imageData, 0, 0);
                tempCtx.fillText((y + 1) + ',' + (x + 1), pieceSize, pieceSize);
                let tempImageURL = tempCanvas.toDataURL("image/png");
                let img = document.getElementById("sliceImage-" + y + "_" + x);
                img.src = tempImageURL;
                img.onclick = function () {
                    currentSlicePic = { x: x, y: y };
                    showLargeImage(fullPicData[y][x], width, height, largeCanvas);
                };
            }
        }
    }

    //生成全图的马赛克大图
    function showFullLargeImage(sourceCanvas, destCanvas) {
        currentSlicePic = { x: -1, y: -1 };
        let imageData = sourceCanvas.getContext('2d').getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
        showLargeImage(imageData, sourceCanvas.width, sourceCanvas.height);
    }

    //生成马赛克大图
    function showLargeImage(imageData, width, height) {
        //首先绘制在backgroundLargeCanvas上，再根据偏移坐标绘到largeCanvas
        backgroundLargeCanvas = document.createElement('canvas');
        let fullLargeCtx = backgroundLargeCanvas.getContext('2d');

        backgroundLargeCanvas.width = width * (pixelSize + 1);
        backgroundLargeCanvas.height = height * (pixelSize + 1);
        fullLargeCtx.font = (~~(pixelSize / 2) + 2) + 'px monospace';
        fullLargeCtx.strokeStyle = '#000';
        fullLargeCtx.textBaseline = 'middle';
        fullLargeCtx.textAlign = 'center';

        //绘制标尺
        drawRulers(width, height);

        //绘制网格
        fullLargeCtx.beginPath();
        for (let x = 1; x < width; x++) {
            fullLargeCtx.moveTo(x * (pixelSize + 1) - 0.5, 0);
            fullLargeCtx.lineTo(x * (pixelSize + 1) - 0.5, backgroundLargeCanvas.height);
            fullLargeCtx.stroke();
        }
        for (let y = 1; y < height; y++) {
            fullLargeCtx.moveTo(0, y * (pixelSize + 1) - 0.5);
            fullLargeCtx.lineTo(backgroundLargeCanvas.width, y * (pixelSize + 1) - 0.5);
            fullLargeCtx.stroke();
        }

        //逐像素读取原图并绘制大图
        let colorSum = new Map();//大图颜色统计
        let totolBeadCount = 0;//总拼豆数
        for (let i = 0; i < imageData.data.length; i += 4) {
            //绘制边框（只有右边和下边）
            let x = (i / 4) % width;
            let y = ~~((i / 4) / width);

            //读取颜色，如果透明则跳过
            let a = imageData.data[i + 3];
            if (a == 0) continue;

            totolBeadCount++;

            let r = imageData.data[i];
            let g = imageData.data[i + 1];
            let b = imageData.data[i + 2];

            //绘制大像素块
            fullLargeCtx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
            fullLargeCtx.fillRect(x * (pixelSize + 1), y * (pixelSize + 1), pixelSize, pixelSize);

            //写文字
            fullLargeCtx.fillStyle = r + g + b > 384 ? '#000' : '#FFF';//浅色黑字，深色白字

            let color = paletteMap.get(rgbToHex(r, g, b));
            //统计颜色或出错信息
            if (color) {
                let key = color.name + '#' + rgbToHex(r, g, b);//统计键值包含了名称和颜色
                if (colorSum.has(key)) colorSum.set(key, colorSum.get(key) + 1);
                else colorSum.set(key, 1);
            }
            else {
                console.log('Error color: ' + rgbToHex(r, g, b));
                if (colorSum.has('Err')) colorSum.set('Err', colorSum.get('Err') + 1);
                else colorSum.set('Err', 1);
            }
            fullLargeCtx.fillText(color ? color.name : 'Err', x * (pixelSize + 1) + ~~(pixelSize * 0.5), y * (pixelSize + 1) + ~~(pixelSize * 0.5));
        }

        //绘制部分图像到largeCanvas
        backgroundCanvasStartOffsetX = 0, backgroundCanvasStartOffsetY = 0;
        backgroundCanvasOffsetX = 0, backgroundCanvasOffsetY = 0;
        showPartLargeCanvas();

        //按颜色数量递减排序
        let colorSumSorted = new Map([...colorSum.entries()].sort(function (a, b) {
            return b[1] - a[1];
        }));

        let sumHtml = '<table class="table"><thead><th> </th><th>颜色</th><th>数量</th></thead><tbody>';
        sumHtml += '<tr><td></td><td>总计</td><td>' + totolBeadCount + '</td></tr>';
        for (let [color, count] of colorSumSorted) {
            //color键分两部分：名称逗号色值
            sumHtml += '<tr><td style="width: 20px; background:#' + color.split('#')[1] + '"> </td><td>' + color.split('#')[0] + '</td><td>' + count + '</td></tr>';
        }
        sumHtml += '</tbody></table>';
        document.getElementById('colorSum').innerHTML = sumHtml;
    }

    //将完整图像数据的一部分绘制到大图
    function showPartLargeCanvas() {
        if (isDrawingLargeCanvas) return;
        isDrawingLargeCanvas = true;
        let fullLargeCtx = backgroundLargeCanvas.getContext('2d'),
            largeCtx = largeCanvas.getContext('2d');

        //重绘后重新计算一次尺寸，避免滚动条影响宽度，使canvas的width和实际宽度不一致
        largeCanvas.width = largeCanvas.clientWidth, largeCanvas.height = largeCanvas.clientWidth;
        //切图时要计算两边的标尺长度
        let viewImageData = fullLargeCtx.getImageData(backgroundCanvasOffsetX, backgroundCanvasOffsetY, largeCanvas.width - 2 * (pixelSize + 1), largeCanvas.height - 2 * (pixelSize + 1));
        largeCtx.putImageData(viewImageData, pixelSize + 1, pixelSize + 1);
        //显示局部标尺
        showPartRulers();
        isDrawingLargeCanvas = false;
    }

    //绘制完整标尺
    function drawRulers(width, height) {
        //初始化四块标尺画布
        rulerX1Canvas = document.createElement('canvas'), rulerX2Canvas = document.createElement('canvas');
        rulerY1Canvas = document.createElement('canvas'), rulerY2Canvas = document.createElement('canvas');
        rulerX1Canvas.width = width * (pixelSize + 1), rulerX1Canvas.height = pixelSize + 1;
        rulerX2Canvas.width = width * (pixelSize + 1), rulerX2Canvas.height = pixelSize + 1;
        rulerY1Canvas.width = pixelSize + 1, rulerY1Canvas.height = height * (pixelSize + 1);
        rulerY2Canvas.width = pixelSize + 1, rulerY2Canvas.height = height * (pixelSize + 1);
        let rulerX1Ctx = rulerX1Canvas.getContext('2d'), rulerX2Ctx = rulerX2Canvas.getContext('2d'),
            rulerY1Ctx = rulerY1Canvas.getContext('2d'), rulerY2Ctx = rulerY2Canvas.getContext('2d');
        rulerX1Ctx.fillStyle = '#000';
        rulerX1Ctx.strokeStyle = '#000';
        rulerX1Ctx.font = (~~(pixelSize / 2) + 2) + 'px monospace';
        rulerX1Ctx.textBaseline = 'middle';
        rulerX1Ctx.textAlign = 'center';
        rulerX2Ctx.fillStyle = '#000';
        rulerX2Ctx.strokeStyle = '#000';
        rulerX2Ctx.font = (~~(pixelSize / 2) + 2) + 'px monospace';
        rulerX2Ctx.textBaseline = 'middle';
        rulerX2Ctx.textAlign = 'center';
        rulerY1Ctx.fillStyle = '#000';
        rulerY1Ctx.strokeStyle = '#000';
        rulerY1Ctx.font = (~~(pixelSize / 2) + 2) + 'px monospace';
        rulerY1Ctx.textBaseline = 'middle';
        rulerY1Ctx.textAlign = 'center';
        rulerY2Ctx.fillStyle = '#000';
        rulerY2Ctx.strokeStyle = '#000';
        rulerY2Ctx.font = (~~(pixelSize / 2) + 2) + 'px monospace';
        rulerY2Ctx.textBaseline = 'middle';
        rulerY2Ctx.textAlign = 'center';

        //横坐标绘制半竖线和文字
        rulerX1Ctx.beginPath();
        rulerX2Ctx.beginPath();
        for (let x = 0; x <= width; x++) {
            //比实际尺寸减0.5像素是由于canvas的绘图方式，防止出现半像素
            rulerX1Ctx.moveTo(x * (pixelSize + 1) - 0.5, ~~(pixelSize * 0.5) - 0.5);
            rulerX1Ctx.lineTo(x * (pixelSize + 1) - 0.5, pixelSize + 1 - 0.5);
            rulerX1Ctx.stroke();
            rulerX2Ctx.moveTo(x * (pixelSize + 1) - 0.5, - 0.5);
            rulerX2Ctx.lineTo(x * (pixelSize + 1) - 0.5, ~~(pixelSize * 0.5) - 0.5);
            rulerX2Ctx.stroke();
            //绘制标尺文字
            if (x < width) {
                rulerX1Ctx.fillText(x + 1, x * (pixelSize + 1) + ~~(pixelSize * 0.5), ~~(pixelSize * 0.5));
                rulerX2Ctx.fillText(x + 1, x * (pixelSize + 1) + ~~(pixelSize * 0.5), ~~(pixelSize * 0.5));
            }
        }
        //纵坐标绘制横竖线和文字
        rulerY1Ctx.beginPath();
        rulerY2Ctx.beginPath();
        for (let y = 0; y <= height; y++) {//横线
            rulerY1Ctx.moveTo(~~(pixelSize * 0.5) - 0.5, y * (pixelSize + 1) - 0.5);
            rulerY1Ctx.lineTo(pixelSize + 1 - 0.5, y * (pixelSize + 1) - 0.5);
            rulerY1Ctx.stroke();
            rulerY2Ctx.moveTo(~~(pixelSize * 0.5) - 0.5, y * (pixelSize + 1) - 0.5);
            rulerY2Ctx.lineTo(- 0.5, y * (pixelSize + 1) - 0.5);
            rulerY2Ctx.stroke();
            if (y < height) {
                rulerY1Ctx.fillText(y + 1, ~~(pixelSize * 0.5), y * (pixelSize + 1) + ~~(pixelSize * 0.5));
                rulerY2Ctx.fillText(y + 1, ~~(pixelSize * 0.5), y * (pixelSize + 1) + ~~(pixelSize * 0.5));
            }
        }
    }

    //将完整标尺的一部分绘制到大图
    function showPartRulers() {
        let largeCtx = largeCanvas.getContext('2d'),
            rulerX1Ctx = rulerX1Canvas.getContext('2d'), rulerX2Ctx = rulerX2Canvas.getContext('2d'),
            rulerY1Ctx = rulerY1Canvas.getContext('2d'), rulerY2Ctx = rulerY2Canvas.getContext('2d');
        //绘制上横标尺
        largeCtx.putImageData(rulerX1Ctx.getImageData(backgroundCanvasOffsetX, 0, largeCanvas.width - 2 * (pixelSize + 1), pixelSize + 1), pixelSize + 1, 0);
        //绘制下横标尺
        largeCtx.putImageData(rulerX2Ctx.getImageData(backgroundCanvasOffsetX, 0, largeCanvas.width - 2 * (pixelSize + 1), pixelSize + 1), pixelSize + 1, largeCanvas.height - pixelSize - 1);
        //绘制左竖标尺
        largeCtx.putImageData(rulerY1Ctx.getImageData(0, backgroundCanvasOffsetY, pixelSize + 1, largeCanvas.height - 2 * (pixelSize + 1)), 0, pixelSize + 1);
        //绘制右竖标尺
        largeCtx.putImageData(rulerY2Ctx.getImageData(0, backgroundCanvasOffsetY, pixelSize + 1, largeCanvas.height - 2 * (pixelSize + 1)), largeCanvas.width - pixelSize - 1, pixelSize + 1);
        //绘制四条标尺边线
        largeCtx.beginPath();
        largeCtx.moveTo(0, pixelSize + 1 - 0.5);
        largeCtx.lineTo(largeCanvas.width, pixelSize + 1 - 0.5);
        largeCtx.stroke();
        largeCtx.moveTo(0, largeCanvas.height - (pixelSize + 1) - 0.5);
        largeCtx.lineTo(largeCanvas.width, largeCanvas.height - (pixelSize + 1) - 0.5);
        largeCtx.stroke();
        largeCtx.moveTo(pixelSize + 1 - 0.5, 0);
        largeCtx.lineTo(pixelSize + 1 - 0.5, largeCanvas.height);
        largeCtx.stroke();
        largeCtx.moveTo(largeCanvas.width - (pixelSize + 1) - 0.5, 0);
        largeCtx.lineTo(largeCanvas.width - (pixelSize + 1) - 0.5, largeCanvas.height);
        largeCtx.stroke();
    }

    //寻找一个颜色最相近的调色板色值
    function findSimilarColor(r, g, b) {
        let hex = rgbToHex(r, g, b);
        //首先查找缓存
        if (similarColorCache.has(hex)) {
            return similarColorCache.get(hex);
        }

        let minDistance = 584970;//最小色差值（初始值为纯黑和纯白的色差，使用colorDistance(0,0,0,255,255,255)计算而得）
        let minColor = null;//最小值对应的颜色
        for (let color of paletteMap.values()) {
            let distance = colorDistance(color.r, color.g, color.b, r, g, b);
            if (distance == 0) {//颜色相等直接返回
                similarColorCache.set(hex, color);//写入缓存
                return color;
            }
            if (distance < minDistance) {
                minDistance = distance;
                minColor = color;
            }
        }

        similarColorCache.set(hex, minColor);//写入缓存
        return minColor;
    }

    //调色板数据生成动态对象以便查询
    function generatePaletteMap(palette) {
        let map = new Map();
        for (let i = 0; i < palette.length; i++) {
            let rgb = hexToRgb(palette[i].color);
            map.set(palette[i].color, {
                name: palette[i].name,
                r: rgb.r,
                g: rgb.g,
                b: rgb.b
            });
        }
        return map;
    }

    //十六进制颜色转rgb数值
    function hexToRgb(hex) {
        let result = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
        } : null;
    }

    //rgb数值转十六进制颜色
    function rgbToHex(r, g, b) {
        let rhex = r.toString(16),
            ghex = g.toString(16),
            bhex = b.toString(16);
        return (rhex.length == 1 ? "0" + rhex : rhex) + (ghex.length == 1 ? "0" + ghex : ghex) + (bhex.length == 1 ? "0" + bhex : bhex);
    }

    //颜色差别公式，简化版，参考https://stackoverflow.com/a/9085524
    function colorDistance(r1, g1, b1, r2, g2, b2) {
        let rmean = (r1 + r2) / 2,
            rd = r1 - r2,
            gd = g1 - g2,
            bd = b1 - b2;
        return (((512 + rmean) * rd * rd) >> 8) + 4 * gd * gd + (((767 - rmean) * bd * bd) >> 8);
    }

    //原生js实现jQuery的ready，详见https://www.sitepoint.com/jquery-document-ready-plain-javascript/
    if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
        onLoad();
    } else {
        document.addEventListener("DOMContentLoaded", onLoad);
    }
</script>
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
<script src="js/popper.min.js"></script>
<script src='bootstrap-4.3.1/js/bootstrap.min.js'></script>

</html>